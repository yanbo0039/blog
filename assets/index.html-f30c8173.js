const e=JSON.parse('{"key":"v-6b0d6eeb","path":"/zh/oracle53/","title":"Oracle-SQL开发 —— 子查询","lang":"zh-CN","frontmatter":{"title":"Oracle-SQL开发 —— 子查询","icon":"page","order":53,"author":"涎涎","date":"2023-01-20T14:19:22.000Z","isOriginal":true,"permalinkPattern":"oracle53","category":["Oracle"],"tag":["Oracle"],"head":[["meta",{"name":"keywords","content":"Oracle-SQL开发 —— 子查询"}],["meta",{"property":"og:url","content":"https://yanbo0039.github.io/blog/blog/zh/oracle53/"}],["meta",{"property":"og:site_name","content":"涎涎的博客"}],["meta",{"property":"og:title","content":"Oracle-SQL开发 —— 子查询"}],["meta",{"property":"og:description","content":"53-Oracle-SQL开发 —— 子查询.md 概念 子查询使用指导 子查询要用括号括起来 将子查询放在比较运算符的右边 对于单行子查询要使用单行运算符 对于多行子查询要使用多行运算符 多行子查询 子查询返回记录的条数 可以是一条或多条。 和多行子查询进行比较时，需要使用多行操作符，多行操作符包括： IN ANY ALL IN操作符和以前介绍的功能一致，判断是否与子查询 的任意一个返回值相同 ROWNUM ROWNUM是一个伪列，伪列是使用上类似于表中的列，而 实际并没有存储在表中的特殊列； ROWNUM的功能是在每次查询时，返回结果集的顺序号， 这个顺序号是在记录输出时才一步一步产生的，第一行 显示为1，第二行为2，以此类推。 ROWNUM使用的注意点： 1.如下SQL语句，SELECT * FROM EMP WHERE ROWNUM&gt;2;查询 不到任何记录，因为ROWNUM是在记录输出时才生成，且总是 从1开始，所以输出的第一条记录不满足&gt;2的条件，被过滤掉， 第二条的ROWNUM又成了1，又不满足〉2的条件，又被过滤掉， 依此类推，所以永远没有满足条件的记录，返回为空。所以 对于ROWNUM只能执行&lt;、&lt;=运算，不能执行&gt;、&gt;=或一个区间 运算Between..And等 2.ROWNUM和ORDER BY一起使用时，因为ROWNUM在记录输出时 生成，而ORDER BY子句在最后执行，所以当两者一起使用时， 需要注意ROWNUM实际是已经被排了序的ROWNUM。 TOP-N查询 Top-N查询主要是实现表中按照某个列排序，输出最大或 最小的N条记录功能。 Top-N分析语法："}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-05-28T05:50:51.000Z"}],["meta",{"property":"article:author","content":"涎涎"}],["meta",{"property":"article:tag","content":"Oracle"}],["meta",{"property":"article:published_time","content":"2023-01-20T14:19:22.000Z"}],["meta",{"property":"article:modified_time","content":"2023-05-28T05:50:51.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Oracle-SQL开发 —— 子查询\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-01-20T14:19:22.000Z\\",\\"dateModified\\":\\"2023-05-28T05:50:51.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"涎涎\\"}]}"]],"description":"53-Oracle-SQL开发 —— 子查询.md 概念 子查询使用指导 子查询要用括号括起来 将子查询放在比较运算符的右边 对于单行子查询要使用单行运算符 对于多行子查询要使用多行运算符 多行子查询 子查询返回记录的条数 可以是一条或多条。 和多行子查询进行比较时，需要使用多行操作符，多行操作符包括： IN ANY ALL IN操作符和以前介绍的功能一致，判断是否与子查询 的任意一个返回值相同 ROWNUM ROWNUM是一个伪列，伪列是使用上类似于表中的列，而 实际并没有存储在表中的特殊列； ROWNUM的功能是在每次查询时，返回结果集的顺序号， 这个顺序号是在记录输出时才一步一步产生的，第一行 显示为1，第二行为2，以此类推。 ROWNUM使用的注意点： 1.如下SQL语句，SELECT * FROM EMP WHERE ROWNUM&gt;2;查询 不到任何记录，因为ROWNUM是在记录输出时才生成，且总是 从1开始，所以输出的第一条记录不满足&gt;2的条件，被过滤掉， 第二条的ROWNUM又成了1，又不满足〉2的条件，又被过滤掉， 依此类推，所以永远没有满足条件的记录，返回为空。所以 对于ROWNUM只能执行&lt;、&lt;=运算，不能执行&gt;、&gt;=或一个区间 运算Between..And等 2.ROWNUM和ORDER BY一起使用时，因为ROWNUM在记录输出时 生成，而ORDER BY子句在最后执行，所以当两者一起使用时， 需要注意ROWNUM实际是已经被排了序的ROWNUM。 TOP-N查询 Top-N查询主要是实现表中按照某个列排序，输出最大或 最小的N条记录功能。 Top-N分析语法："},"headers":[],"git":{"createdTime":1684701424000,"updatedTime":1685253051000,"contributors":[{"name":"涎涎","email":"yanbo0039@yeah.net","commits":2}]},"readingTime":{"minutes":12.93,"words":3878},"filePathRelative":"zh/programBlog/Database/Oracle/53-Oracle-SQL开发 —— 子查询.md","localizedDate":"2023年1月20日","excerpt":"<!-- more -->\\n<h1> 53-Oracle-SQL开发 —— <a href=\\"http://xn--i8ss60ay71a.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">子查询.md</a></h1>\\n<h4> 概念</h4>\\n<figure><img src=\\"/assets/Oracle_53_1.png\\" alt=\\"\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption></figcaption></figure>\\n<ul>\\n<li>\\n<p>子查询使用指导</p>\\n<ul>\\n<li>子查询要用括号括起来</li>\\n<li>将子查询放在比较运算符的右边</li>\\n<li>对于单行子查询要使用单行运算符</li>\\n<li>对于多行子查询要使用多行运算符</li>\\n</ul>\\n</li>\\n<li>\\n<p>多行子查询</p>\\n<ul>\\n<li>子查询返回记录的条数 可以是一条或多条。</li>\\n<li>和多行子查询进行比较时，需要使用多行操作符，多行操作符包括：\\n<ul>\\n<li>IN</li>\\n<li>ANY</li>\\n<li>ALL</li>\\n</ul>\\n</li>\\n<li>IN操作符和以前介绍的功能一致，判断是否与子查询\\n的任意一个返回值相同</li>\\n</ul>\\n</li>\\n<li>\\n<p>ROWNUM</p>\\n<ul>\\n<li>ROWNUM是一个伪列，伪列是使用上类似于表中的列，而\\n实际并没有存储在表中的特殊列；</li>\\n<li>ROWNUM的功能是在每次查询时，返回结果集的顺序号，\\n这个顺序号是在记录输出时才一步一步产生的，第一行\\n显示为1，第二行为2，以此类推。</li>\\n</ul>\\n</li>\\n<li>\\n<p>ROWNUM使用的注意点：</p>\\n<ul>\\n<li>1.如下SQL语句，SELECT * FROM EMP WHERE ROWNUM&gt;2;查询\\n不到任何记录，因为ROWNUM是在记录输出时才生成，且总是\\n从1开始，所以输出的第一条记录不满足&gt;2的条件，被过滤掉，\\n第二条的ROWNUM又成了1，又不满足〉2的条件，又被过滤掉，\\n依此类推，所以永远没有满足条件的记录，返回为空。所以\\n对于ROWNUM只能执行&lt;、&lt;=运算，不能执行&gt;、&gt;=或一个区间\\n运算Between..And等</li>\\n<li>2.ROWNUM和ORDER BY一起使用时，因为ROWNUM在记录输出时\\n生成，而ORDER BY子句在最后执行，所以当两者一起使用时，\\n需要注意ROWNUM实际是已经被排了序的ROWNUM。</li>\\n</ul>\\n</li>\\n<li>\\n<p>TOP-N查询</p>\\n<ul>\\n<li>Top-N查询主要是实现表中按照某个列排序，输出最大或\\n最小的N条记录功能。</li>\\n<li>Top-N分析语法：</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
