import{_ as r,X as a,Y as d,a1 as n,Z as t,$ as e,a2 as l,a0 as o,F as s}from"./framework-68dd73a2.js";const h="/blog/assets/Java_135_1.png",u="/blog/assets/Java_135_2.png",c="/blog/assets/Java_135_3.png",f="/blog/assets/Java_135_4.png",p="/blog/assets/Java_135_5.png",_={},b={id:"_135-java-流的概念及api-md",tabindex:"-1"},g=t("a",{class:"header-anchor",href:"#_135-java-流的概念及api-md","aria-hidden":"true"},"#",-1),v={href:"http://xn--135-Java-API-4j0uq53k363ansmwl2b.md",target:"_blank",rel:"noopener noreferrer"},m=o('<div class="hint-container warning"><p class="hint-container-title">注意</p><p>本博文仅供学术研究和交流参考，严禁将其用于商业用途。如因违规使用产生的任何法律问题，使用者需自行负责。</p></div><ul><li><p>流的概念</p><ul><li>流（Stream )的概念代表的是程序中数据的流通</li><li>数据流是一串连续不断的数据的集合</li><li>在Java程序中，对于数据的输入/输出操作是以流(Stream)的方式进行的 <ul><li>输入流 — 流入程序的数据</li><li>输出流 — 流出程序的数据</li><li>在java程序中，从输入流读取数据（读到内存中），而从输出流输出数据（从内存存储到文件或显示到屏幕上）</li></ul></li></ul></li><li><p>流的概念</p><ul><li>流的分类 <ul><li>按流的方向不同 <ul><li>输入流、输出流</li></ul></li><li>按处理数据的单位不同 <ul><li>字节流、字符流</li></ul></li><li>按功能不同 <ul><li>节点流、处理流</li></ul></li></ul></li></ul></li><li><p>Java语言中，控制数据流的类都放在java.io包中</p></li></ul><table><thead><tr><th></th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table><ul><li><p>java.io包中有两大继承体系</p><ul><li>以byte处理为主的Stream类，他们的命名方式是XXXStream</li><li>以字符处理为主的Reader / Writer类，他们的命名方式XXXReader或XXXWriter</li></ul></li><li><p>InputStream、OutputStream、Reader、Writer这四个类，是这两大继承体系的父类</p></li><li><p>流的层次结构图</p></li></ul><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>字节输入流的层次结构图</li></ul><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>字节输入流的主要方法 <ul><li>此抽象类是表示输入字节流的所有类的超类</li><li>InputStream常用的方法</li></ul></li></ul><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>int read( )</td><td>一次读取一个byte的数据，并以int类型把数据返回来，如果没有数据可以读了，会返回”-1”</td></tr><tr><td>int read(byte[] buffer)</td><td>把所读取到的数据放在这个byte数组中，返回一个int型的数据，这个int型数据存储了返回的真正读取到的数据byte数</td></tr><tr><td>int read(byte[] buffer,int offset,int length)</td><td>读取length个字节，并存储到一个字节数组buffer中，并从offset位置开始返回实际读取的字节数</td></tr><tr><td>void close( )</td><td>关闭此输入流并释放与该流关联的所有系统资源</td></tr></tbody></table><ul><li>字节输出流的层次结构图</li></ul><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>字节输出流的主要方法 <ul><li>此抽象类是表示输出字节流的所有类的超类</li><li>OutputStream常用的方法</li></ul></li></ul><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>void write(byte[] buffer)</td><td>将要输出的数组先放在一个byte数组中，然后用这个方法一次把一组数据输出出去</td></tr><tr><td>void write(byte[] buffer,int off,int len)</td><td>将指定字节数组中从偏移量 off 开始的 len 个字节写入此输出流</td></tr><tr><td>abstract void write(int b)</td><td>将指定的字节写入此输出流</td></tr><tr><td>void close( )</td><td>关闭此输出流并释放与此流有关的所有系统资源</td></tr><tr><td>void flush( )</td><td>刷新此输出流并强制写出所有缓冲的输出字节</td></tr></tbody></table><ul><li>字符输入流的层次结构图</li></ul><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>字符输入流的主要方法 <ul><li>用于输入字符流的抽象类</li><li>Reader常用的方法</li></ul></li></ul><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>int read( )</td><td>一次读取一个char的数据，并以int类型把数据返回来，如果没有数据可以读了，会返回”-1”</td></tr><tr><td>int read(char[] cbuffer)</td><td>把所读取到的数据放在这个char数组中，返回一个int型的数据，这个int型数据存储了返回的真正读取到的数据char数</td></tr><tr><td>int read(char[] cbuffer,int offset,int length)</td><td>读取length个字符，并存储到一个字节数组cbuffer中，并从offset位置开始返回实际读取的字符数</td></tr><tr><td>void close( )</td><td>关闭此Reader并释放与其关联的所有系统资源</td></tr></tbody></table><ul><li>字符输出流的层次结构图</li></ul><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>字符输出流的主要方法 <ul><li>输出字符流的抽象类</li><li>Writer常用的方法</li></ul></li></ul><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>void write(char[] cbuffer)</td><td>将要输出的数组先放在一个char数组中，然后用这个方法一次把一组数据输出出去</td></tr><tr><td>void write(char[] cbuffer,int off,int len)</td><td>将指定字符数组中从偏移量 off 开始的 len 个字符写入此输出流</td></tr><tr><td>int write(int b)</td><td>将指定的字符写入此输出流</td></tr><tr><td>void write(String str)</td><td>写入字符串</td></tr><tr><td>void write(String str, int off,int len)</td><td>将指定字符串中从偏移量 off 开始的 len 个字符写入此输出流</td></tr><tr><td>void close( )</td><td>关闭此输出流并释放与此流有关的所有系统资源</td></tr><tr><td>void flush( )</td><td>刷新此输出流并强制写出所有缓冲的输出字符</td></tr></tbody></table><h3 id="拓展知识" tabindex="-1"><a class="header-anchor" href="#拓展知识" aria-hidden="true">#</a> 拓展知识：</h3>',22),y={href:"https://www.runoob.com/java/java8-new-features.html",target:"_blank",rel:"noopener noreferrer"},w={href:"https://blog.csdn.net/qq_38078822/article/details/80836539",target:"_blank",rel:"noopener noreferrer"},x={href:"https://www.jianshu.com/p/ae88f99f9cb9",target:"_blank",rel:"noopener noreferrer"},j={href:"https://www.w3cschool.cn/java/java-stream-api.html",target:"_blank",rel:"noopener noreferrer"},J=t("hr",null,null,-1),S=t("h3",{id:"分割线",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#分割线","aria-hidden":"true"},"#"),e(" 分割线")],-1),k=t("hr",null,null,-1),I=t("div",{class:"hint-container tip"},[t("p",{class:"hint-container-title"},"提示"),t("p",null,[t("strong",null,[e("以上就是我关于 "),t("em",null,"Java-流的概念及API"),e(" 知识点的整理与总结的全部内容")])])],-1);function X(R,z){const i=s("ExternalLinkIcon");return a(),d("div",null,[n(" more "),t("h1",b,[g,e(),t("a",v,[e("135-Java-流的概念及API.md"),l(i)])]),m,t("p",null,[t("a",y,[e("Java 8 新特性"),l(i)])]),t("p",null,[t("a",w,[e("java中 ->"),l(i)])]),t("p",null,[t("a",x,[e("Java8新特性5--流式API"),l(i)])]),t("p",null,[t("a",j,[e("Java 流API - w3cschool"),l(i)])]),J,S,k,I])}const N=r(_,[["render",X],["__file","java135.html.vue"]]);export{N as default};
