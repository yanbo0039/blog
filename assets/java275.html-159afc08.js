import{_ as e,X as i,Y as a,a1 as t,a0 as l}from"./framework-68dd73a2.js";const r={},n=l('<h1 id="java23种设计模式及其应用场景" tabindex="-1"><a class="header-anchor" href="#java23种设计模式及其应用场景" aria-hidden="true">#</a> Java23种设计模式及其应用场景</h1><div class="hint-container warning"><p class="hint-container-title">注意</p><p>本博文仅供学术研究和交流参考，严禁将其用于商业用途。如因违规使用产生的任何法律问题，使用者需自行负责。</p></div><blockquote><p>实际上，Java并没有正式的23种设计模式。 23种设计模式是由Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides在《设计模式： 可复用面向对象软件的基础》一书中提出的，并且主要针对面向对象编程语言而言。</p></blockquote><ul><li>Java中常用的设计模式包括但不限于以下几种：</li></ul><ol><li>单例模式（Singleton Pattern）：确保一个类只有一个实例。示例：数据库连接池、日志系统、线程池等需要全局唯一实例的场景。</li><li>工厂模式（Factory Pattern）：通过工厂类创建对象，而不是直接使用new关键字。示例：创建不同类型的图形对象（圆形、矩形、三角形）。</li><li>抽象工厂模式（Abstract Factory Pattern）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定具体类。示例：创建不同操作系统下的窗口和按钮。</li><li>建造者模式（Builder Pattern）：将复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。示例：创建包含多个组件的复杂对象，如电子邮件。</li><li>原型模式（Prototype Pattern）：通过复制现有对象来创建新对象，而不是通过实例化。示例：克隆对象，创建相似但不同的对象。</li><li>适配器模式（Adapter Pattern）：将一个类的接口转换为另一个类所期望的接口。示例：将旧的API适配到新的API，使其能够兼容。</li><li>装饰器模式（Decorator Pattern）：动态地给对象添加额外的职责，不改变其结构。示例：给文本编辑器添加字体、颜色等装饰功能。</li><li>观察者模式（Observer Pattern）：定义对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，其依赖者会收到通知并自动更新。示例：事件处理机制，监听器模式。</li><li>策略模式（Strategy Pattern）：定义一系列算法，使得可以在运行时选择其中之一来完成特定任务。示例：支付方式选择，根据不同策略计算价格。</li><li>模板方法模式（Template Method Pattern）：定义一个算法的骨架，将一些步骤的实现延迟到子类中。示例：框架中的钩子方法，控制流程的固定部分。</li><li>迭代器模式（Iterator Pattern）：提供一种顺序访问集合中各个元素的方式，而无需暴露集合的内部表示。示例：集合类的迭代器，遍历列表、树等数据结构。</li><li>外观模式（Facade Pattern）：为一组复杂的子系统提供一个简化的接口。示例：操作系统的API接口、第三方库的封装。</li><li>组合模式（Composite Pattern）：将对象组合成树形结构以表示“部分-整体”的层次关系。示例：文件系统的目录和文件结构。</li><li>状态模式（State Pattern）：允许对象在内部状态改变时改变它的行为。示例：电梯系统中的状态切换（开门、关门、上行、下行）。</li><li>空对象模式（Null Object Pattern）：为了解决对象为空时的处理问题，引入一个空对象来代替真实的空对象。示例：缓存系统、日志记录、集合类操作、观察者模式、数据库查询</li><li>访问者模式（Visitor Pattern）：定义了对对象结构中的元素进行操作的操作，可以在不改变元素类的前提下定义新的操作。示例：XML解析器、编译器的语义分析。</li><li>命令模式（Command Pattern）：将请求封装为一个对象， 从而使可以用不同的请求对客户进行参数化。示例：菜单项的点击事件、撤销操作。</li><li>备忘录模式（Memento Pattern）：在不破坏封装性的前提下，捕获并保存一个对象的内部状态。示例：撤销操作、游戏进度保存。</li><li>过滤器模式（Filter Pattern）：使用不同的标准筛选一组对象，获取符合条件的子集。示例：数据库查询、日志记录、图片处理、数据校验、请求处理</li><li>桥接模式（Bridge Pattern）：将抽象部分与它的实现部分分离，使它们可以独立地变化。示例：不同颜色和形状的图形对象。</li><li>责任链模式（Chain of Responsibility Pattern）：通过为请求创建一个对象链，使得每个对象都有机会处理请求。示例：日志记录器链、请求过滤器。</li><li>解释器模式（Interpreter Pattern）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，用来解释该语言中的句子。示例：编译器、正则表达式解析。</li><li>媒体模式/中介者模式（Mediator Pattern）：通过封装一组对象之间的交互，使得对象之间不需要显式地相互引用。示例：聊天室中的消息传递。</li></ol><ul><li>这些是常见的设计模式，但并不意味着在每个项目中都需要使用所有的设计模式。选择使用哪些设计模式取决于项目的需求和设计目标。</li></ul><hr><h3 id="分割线" tabindex="-1"><a class="header-anchor" href="#分割线" aria-hidden="true">#</a> 分割线</h3><hr><div class="hint-container info"><p class="hint-container-title">相关信息</p><p><strong>以上就是我关于 <em>Java23种设计模式及其应用场景</em> 知识点的整理与总结的全部内容，希望对你有帮助。。。。。。。</strong></p></div>',10);function o(c,s){return i(),a("div",null,[t(" more "),t(" sticky "),n])}const h=e(r,[["render",o],["__file","java275.html.vue"]]);export{h as default};
