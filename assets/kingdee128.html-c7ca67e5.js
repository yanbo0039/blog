import{_ as o,X as r,Y as s,a1 as l,Z as e,$ as i,a2 as t,a0 as n,F as c}from"./framework-68dd73a2.js";const g="/blog/assets/Kingdee_128_1.png",d="/blog/assets/Kingdee_128_2.png",p="/blog/assets/Kingdee_128_3.png",h="/blog/assets/Kingdee_128_4.png",_="/blog/assets/Kingdee_128_5.png",f="/blog/assets/Kingdee_128_6.png",m="/blog/assets/Kingdee_128_7.png",u={},b={id:"_128-eas中常见追踪标准方法的源代码实现套路-md",tabindex:"-1"},x=e("a",{class:"header-anchor",href:"#_128-eas中常见追踪标准方法的源代码实现套路-md","aria-hidden":"true"},"#",-1),k={href:"http://xn--128-EAS-m43k06ce3n2ow4hgknjpm1a22hm4tg3g2yz6im1hhg04h5htapgbh6y.md",target:"_blank",rel:"noopener noreferrer"},E=n('<div class="hint-container warning"><p class="hint-container-title">注意</p><p>本博文仅供学术研究和交流参考，严禁将其用于商业用途。如因违规使用产生的任何法律问题，使用者需自行负责。</p></div><h3 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景" aria-hidden="true">#</a> 应用场景</h3><blockquote><p>最近笔者在EAS项目中实现一个生成凭证的功能，即调用标准方法 generateVoucher(),如下图所示</p></blockquote><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>如下图我们可知，其只需要传对应的参数即可实现功能，那么有时候我们就想看看，其到底是如何实现此功能的呢？</p></blockquote><h3 id="事前准备" tabindex="-1"><a class="header-anchor" href="#事前准备" aria-hidden="true">#</a> 事前准备</h3><ol><li><p>开发工具 -Eclipse</p></li><li><p>实现反编译</p></li></ol>',7),v={href:"https://www.jianshu.com/p/0128a0c3e7d5",target:"_blank",rel:"noopener noreferrer"},y=n('<ol start="3"><li><p>EAS客户/服务端 安装成功，此步骤不作介绍</p></li><li><p>BOS开发工具安装成功 ，此步骤不作介绍</p></li></ol><h3 id="操作步骤" tabindex="-1"><a class="header-anchor" href="#操作步骤" aria-hidden="true">#</a> 操作步骤</h3><blockquote><p>我们常规操作就是按住ctrl键配置鼠标的单击键直接进入看源码，如下图所示，我们进入方法所看到的只是此方法的抽象方法以及一个抽像类，那么如何才能找到此方法的实现方法，以及此类的实现类呢？这就需要我们掌握基本套路</p></blockquote><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>首先我们进入此类方法的controllerBean中，在Java视图快捷键ctrl + shift + t搜索</li></ol><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li>进入此类中连续两次ctrl + o 查看父类的父类的方法，得记住之前方法的参数，输入_generateVoucher找到对应的方法点击进入即可</li></ol><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="3"><li>如下图所示，即找到了此方法的实现源代码</li></ol><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="分割线" tabindex="-1"><a class="header-anchor" href="#分割线" aria-hidden="true">#</a> 分割线</h3><hr><div class="hint-container tip"><p class="hint-container-title">提示</p><p><strong>以上就是我关于 <em>EAS中常见追踪标准方法的源代码实现套路</em> 知识点整理与总结的全部内容，希望对你有帮助。。。。。。。</strong></p></div>',16);function z(q,K){const a=c("ExternalLinkIcon");return r(),s("div",null,[l(" more "),e("h1",b,[x,i(),e("a",k,[i("128-EAS中常见追踪标准方法的源代码实现套路.md"),t(a)])]),E,e("blockquote",null,[e("p",null,[i("如不知如何实现Eclipse工具的反编译，请参考笔者的另一篇博客"),e("a",v,[i("Eclipse如何设置反编译查看Java源码？"),t(a)])])]),y])}const V=o(u,[["render",z],["__file","kingdee128.html.vue"]]);export{V as default};
